%I think this module was a mistake, and wont be used.


%your id is how deep your account is in the accounts database.
%when accounts are created, if they use your pubkey, then the account is added to this module's memory. 
%It would be cool if we had a way to automatically consolidate funds into one ID. (It should prefer lower-numbered IDs)
-module(id).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2, id/0,ids/0,add/1,remove/1,clean/0]).
-define(LOC, "id.db").
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("keys died"), ok.
-record(id, {created = 0, id = 0})
-record(f, {a = [#id{}, b = -1]}).%the zero is for the master account with all the money. 
-record(acc, {balance = 0, nonce = 0, pub = ""}).
init(ok) -> 
    X = db:read(?LOC),
    if
        X == "" -> 
	    K = #f{},
            db:save(?LOC,K);
        true -> K = X
    end,
    {ok, K}.
max_balance([Id|Ids]) -> max_balance(Ids, Id, block_tree:account(Id#id.id), keys:pubkey()).
max_balance([Id|Ids], WinnerId, Acc1, Pubkey) -> 
    Acc2 = block_tree:account(Id#id.id),
    B1 = Acc1#acc.balance,
    B2 = Acc2#acc.balance,
    if
	not (Acc1#acc.pub == Pubkey) -> max_balance(Ids, Id, Acc2, Pubkey);
	not (Acc2#acc.pub == Pubkey) -> max_balance(Ids, WinnerId, Acc1, Pubkey);
	B1 > B2 -> max_balance(Ids, WinnerId, Acc1, Pubkey);
	true -> max_balance(Ids, Id, Acc2, Pubkey)
    end.
max_balance([], X, _, _) -> X#id.id.
handle_call(id, _From, R) -> 
    if
	R#f.b == -1 -> 
	    Y = max_balance(R#f.a),
	    X = Y#id.id,
	    {reply, X, #f{a = R#f.a, b = X}}
	true -> {reply, R#f.b, R}
    end.
handle_call(ids, _From, R) -> {reply, R#f.a, R}.
clean([], _, _) -> [];
clean([Id|T], Cutoff, Pubkey) when Id#id.created < Cutoff -> 
    Acc = block_tree:account(Id#id.id),
    if
	Acc#acc.pub == Pubkey -> [Id|clean(T, Cutoff, Pubkey)];
	true -> clean(T, Cutoff, Pubkey)
    end.
handle_cast(clean, R) -> 
%along with each ID, we should store a pointer to when the id got created. That way, if we are more than finality past where the id got created, and it still doesn't use my pubkey, I can remove it from this list.
    Height = block_tree:height(block_tree:read(top)),
    Cutoff = Height-constants:finality(),
    {noreply, #f{a = clean(R#f.a, Cutoff, keys:pubkey())}};
handle_cast({add, Id, Height}, R) -> 
    I = #id{id = Id, created = Height},
    {noreply, #f{a = [I|R], b = R#f.b}};	     
handle_cast({remove, Id}, R) -> {noreply, #f{a = remove(Id, R#f.a), b = R#f.b}}.
remove(X, L) -> remove(X, L, []).
remove(X, [Id|T], L) when Id#id.id == X -> T ++ L;
remove(X, [Id|T], L) -> remove(X, T, [Id|L]);
remove(X, [], L) -> L.

remove(Id) -> gen_server:cast(?MODULE, {remove, Id}).
add(Id, Height) -> 
    %we caould add a check that Height is current height or less.
    gen_server:cast(?MODULE, {add, Id, Height}).
id() -> gen_server:call(?MODULE, id).
ids() -> gen_server:call(?MODULE, ids).%This will return your id that currently has the biggest balance
clean() -> gen_server:cast(?MODULE, clean).%deletes ids that are older than finality and don't use your pubkey. garbage collection 
