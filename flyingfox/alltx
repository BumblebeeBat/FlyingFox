defmodule Api do
  defp lh do "localhost" end
  defp lp do KV.get("port") end
  defp talk(msg, port, ip) do 
    case Tcp.talk(ip, port, msg) do
      {:ok, x} -> x
      {:error, x} -> [error: x, port: port, ip: ip]
    end
  end
  def add_block(block, port \\ lp, ip \\ lh) do 
  talk([:add_block, block], port, ip ) end 
  def txs(port \\ lp, ip \\ lh) do 
  talk([:txs], port, ip) end
  def pushtx(tx, port \\ lp, ip \\ lh) do 
  talk([:pushtx, tx], port, ip) end
  def blocks(start, finish, port \\ lp, ip \\ lh) do 
  talk([:blocks, start, finish], port, ip) end
  def add_peer(peer, port \\ lp, ip \\ lh) do 
  talk([:add_peer, peer], port, ip) end
  def all_peers(port \\ lp, ip \\ lh) do 
  talk([:all_peers], port, ip) end
  def status(port \\ lp, ip \\ lh) do
  talk([:status], port, ip) end
end
defmodule BlockAbsorber do#this doesn't actually have memory. so I used "x" to fill in spaces.
  use GenServer
  def key do :absorber end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do 
    Blocktree.genesis_state
    Keys.master  
    {:ok, []} 
  end
  def handle_call({:blocks, blocks}, _from, x) do 
    Blocktree.add_blocks(blocks)
    {:reply, :ok, x}
  end
  def absorb(blocks) do GenServer.call(key, {:blocks, blocks}) end
  def buy_block do GenServer.call(key, {:blocks, [Blockchain.buy_block]}) end
  def buy_blocks(n) do Enum.map(1..n, fn(_) -> 
        :timer.sleep(1000)
        buy_block 
        TxCreator.sign
        TxCreator.reveal
      end) 
  end
end
defmodule Blockchain do#the part the blocktree we care about is the blockchain, it ends in the most recent valid block.
  def txs_filter(txs, type) do Enum.filter(txs, fn(t) -> t[:data][:type]==type end) end
  def being_spent(txs) do txs |> txs_filter("spend") |> Enum.map(fn(t) -> t[:data][:amount] end) |> Enum.reduce(0, &(&1+&2)) end
  def prev_block(block) do KV.get(block[:data][:hash]) end
  def valid_block?(block, cost) do 
    #block creator needs to pay a fee. he needs to have signed so we can take his fee.
    f = fn(x) -> x[:data][:bond_size] end
    prev = prev_block(block)
    prev2 = prev_block(prev)
    prev3 = prev_block(prev2)
    min_bond = max(f.(prev), max(f.(prev2), f.(prev3)))
    if min_bond == nil do min_bond = 100000 end
    ngenesis = block[:data][:height]!=1
    cond do
      not is_list(block) -> 
        IO.puts("block should be a dict #{inspect block}")
        false
      min_bond*2/3>f.(block) ->#if the amount of money bonded per block changes too quickly, then it makes it more likely for double-spends to happen.
        IO.puts("not enough bonded")
        false
      ngenesis and prev == Constants.empty_account ->
        IO.puts("blocks come from parents: #{inspect block}")
        IO.puts(inspect block[:data][:height])
        false
      ngenesis and block[:data][:height] - prev[:data][:height] < 1 ->
        IO.puts("cannot redo history")
        false
      not Sign.verify_tx(block) -> 
        IO.puts("bad signature #{inspect block}")
        false
      true ->
        valid_block_2?(block, cost)
    end
  end
  def winners(block) do block[:data][:txs] |> txs_filter("sign") |> Enum.map(&(length(&1[:data][:winners]))) |> Enum.reduce(0, &(&1+&2)) end
  def valid_block_2?(block, cost) do
    wins = winners(block)
    cond do
      wins < Constants.signers_per_block*2/3 -> 
        IO.puts("not enough signers #{inspect wins}")
        IO.puts("block: #{inspect block}")
        false
      not VerifyTx.check_txs(block, cost) ->
        IO.puts("invalid tx")
        false
      true -> valid_block_3?(block, wins) 
    end
  end
  def valid_block_3?(block, ns) do
    txs = block[:data][:txs] 
    sign_txs=txs_filter(txs, "sign")
    signers = Enum.map(sign_txs, fn(t) -> t[:pub] end)
    accs = Enum.map(signers, fn(s) -> KV.get(s) end)
    balances = Enum.map(accs, fn(s) -> s[:bond] end)
    poorest_balance = Enum.reduce(balances, nil, &(min(&1, &2)))
    spending=being_spent(txs)
    bs=block[:data][:bond_size]
    cond do
      poorest_balance < bs -> 
        IO.puts("poorest signer cant afford")
        false
      bs*ns<spending*3 -> 
        IO.puts("not enough bonds to spend that much")
        false
      true -> true
    end
  end
  def get_helper(h) do KV.get(to_string(h)) end#ran 1444 times to add first 2 blocks?!?!
  def get_block(h) do#ran 1444 times to add first 2 blocks?!?!
    if is_integer(h) do h=hd(get_helper(h)) end
    KV.get(h)
  end
  def buy_block(n \\ 1) do
    true = n>0
    height=KV.get("height")
    prev_block = get_block(KV.get("height"))
    txs=Mempool.txs#remove expensive txs until we can afford it. packing problem.
    bh=nil 
    if prev_block != Constants.empty_account do 
      bh=Blocktree.blockhash(prev_block)
    end
    new=[height: height+n, txs: txs, hash: bh, bond_size: 10_000_000_000_000/Constants.signers_per_block*3]#instead of fixed bond size, we shoul look at how big of a bond the txs need.
    new = Keys.sign(new)
    Dict.put(new, :meta, [revealed: []])
  end
  def num_signers(txs) do 
    txs_filter(txs, "sign")
    |> Enum.map(fn(t) -> length(t[:data][:winners]) end) 
    |> Enum.reduce(0, &(&1+&2))
  end
  def back do
    h=KV.get("height")
    if h>0 do
        block = get_block(h)
        prev = get_block(block[:data][:hash])
        txs=block[:data][:txs]
        n=num_signers(txs)
        TxUpdate.txs_updates(txs, -1, round(block[:data][:bond_size] / n))
        TxUpdate.sym_increment(block[:pub], :amount, -Constants.block_creation_fee, -1)
        b = prev[:data][:height]
        if b==nil do b=0 end
        KV.put("height", b)
        Mempool.dump
        true 
    end
  end
  def forward(block) do#while walking forward this needs to reorder the hashes used for get_block so that the block we are using is on top. I thought we only store one of the blockhashes...
    if not is_list(block) do block = KV.get(block) end
    gap = block[:data][:height]-KV.get("height")
    cost = Constants.block_creation_fee*round(:math.pow(2, gap))
    cond do
      not is_list(block) -> [error: "blocks should be lists"]
      KV.get(Blocktree.blockhash(block)) == Constants.empty_account -> [error: "don't have this block"]
      gap < 1 -> [error: "cannot redo history"]
      not valid_block?(block, cost) -> 
        IO.puts("invalid block")
        false      
      true ->
        #block creator needs to pay a fee. he needs to have signed so we can take his fee.
        TxUpdate.sym_increment(block[:pub], :amount, -cost, 1)#if I skip blocks, charge more
        txs=block[:data][:txs]
        n=num_signers(txs)
        TxUpdate.txs_updates(txs, 1, round(block[:data][:bond_size]/n))
        KV.put("height", block[:data][:height])
        Mempool.dump
        hash = Blocktree.blockhash(block)
        n = to_string(block[:data][:height])
        bh = KV.get(n) |> Enum.filter(&(&1!=hash))
        KV.put(n, [hash|bh])
    end
  end
  def goto(hash) do
    h = hash |> get_block
    goto_helper([h])
  end
  def goto_helper(last_blocks) do
    h = KV.get("height")
    if h==0 do 
      my_block = [height: 0]
      hash = ""
    else
      my_block=get_block(h)[:data] 
      hash = Blocktree.blockhash(my_block)
    end
    add_block = hd(last_blocks)[:data]
    cond do
      length(last_blocks)>60 -> 
        IO.puts("error!#! #{inspect last_blocks}")
      hd(last_blocks) == [amount: 0, bond: 0, wait: {0, 0}, nonce: 0] ->
        IO.puts("error 2 #{inspect last_blocks}")
        Enum.map(tl(last_blocks), &(forward(&1)))
      my_block[:height] == 0 or add_block[:hash] == hash -> 
        Enum.map(last_blocks, &(forward(&1)))
      add_block[:height] > my_block[:height] ->
        IO.puts("always here")
        goto_helper([get_block(add_block[:hash])|last_blocks])
      true ->
        IO.puts("back")
        back
        goto_helper(last_blocks)
    end
  end
end
defmodule Blocktree do
  def blockhash(block) do
    if :data in Dict.keys(block) do block=block[:data] end
    DetHash.doit(block)
  end
  def genesis_block do
    new=[meta: [revealed: []], data: [height: 0, txs: []]]
    KV.put("height", 0)
    KV.put("0", ["genesis"])
    KV.put("genesis", new)
  end
  def sign_reveal do
    TxCreator.sign
    TxCreator.reveal
  end
  def get_helper(h) do KV.get(to_string(h)) end
  def get_block(h) do#ran 1444 times to add first 2 blocks?!?!
    if is_integer(h) do h=hd(get_helper(h)) end
    KV.get(h)
  end
  def put_block(block) do
    height = block[:data][:height] 
    block_hash = blockhash(block)
    block_hashes = height |> get_helper
    if block_hash in block_hashes do false else
      if block_hashes ==Constants.empty_account do block_hashes = [] end
      block_hashes = block_hashes++[block_hash]
      KV.put(to_string(height), block_hashes)
      KV.put(block_hash, Dict.put(block, :meta, [revealed: []]))
      block_hash
    end
  end
  def genesis_state do
    genesis_block
    a=Constants.empty_account
    ac=Constants.initial_coins
    b = ac/21
    a = Dict.put(a, :amount, 20*b)
    a = Dict.put(a, :bond, b)
    Keys.master
    creator_pub = Keys.pubkey
    KV.put(creator_pub, a)
    KV.put("tot_bonds", b)
    KV.put("", [height: 0, hash: ""])
    sign_reveal
  end
  def quick_validation(block) do
    #IO.puts("block #{inspect block}")
    ran=VerifyTx.rng(block[:data][:hash])
    tot_bonds = KV.get("tot_bonds")
    l = Blockchain.txs_filter(block[:data][:txs], "sign")
    |> Enum.map(fn(sign) -> 
      acc = KV.get(sign[:pub])
      Enum.map(sign[:data][:winners], fn(x)-> 
        VerifyTx.winner?(acc[:bond], tot_bonds, ran, sign[:pub], x) 
      end) 
    end) |> Enum.reduce([], &(&1++&2)) |> Enum.map(&(if(&1) do 1 else 0 end)) |> Enum.reduce(0, &(&1+&2))
    cond do
      Blockchain.winners(block) <= Constants.signers_per_block*2/3 -> 
        IO.puts("not enough winners")
        false
      l <= Constants.signers_per_block*1/2 -> 
        IO.puts("not enough")
        false
      true -> true
    end
  end
  def enough_validated(blocks, n) do
    cond do
      n == 0 -> true
      blocks == [] -> false
      not quick_validation(hd(blocks)) ->
        IO.puts("bad block")
        false
      true ->
        enough_validated(tl(blocks), n-1)
    end
  end
  def add_blocks(blocks) do#make sure the networking nodes can pass >30 blocks before calling this function.
    cond do
      blocks == [] -> []
      not :pub in Dict.keys(hd(blocks)) -> add_blocks(tl(blocks))
      not enough_validated(blocks, round(length(KV.get(hd(blocks)[:data][:height]))/3)) ->#should say "KV.get" in this line!!
         IO.puts("double-signing everywhere")
         false
      KV.get(blockhash(hd(blocks))) != Constants.empty_account ->
        IO.puts("already have this block")
        add_blocks(tl(blocks))
      true ->
        block_hash = put_block(hd(blocks))
        current_height = KV.get("height")
        if hd(blocks)[:data][:height]>current_height do Blockchain.goto(block_hash) end
        add_blocks(tl(blocks))
    end
  end
end
defmodule Cli do
  def buy_blocks(n \\ 1) do spawn_link(fn()->(BlockAbsorber.buy_blocks(n)) end) end
  def buy_block do buy_blocks(1) end
  def spend(amount, to) do TxCreator.spend(amount, to) end
  def start do Main.start end
  def block(n) do Blockchain.get_block(n) end
  def txs do Mempool.txs end
end
#these constants are the same for every node on the chain.
defmodule Constants do
  def initial_coins do 2_100_000_000_000_000 end
  def minbond do 2_000_000_000 end
  def min_tx_fee do 5000 end
  def block_creation_fee do 31_000_000 end
  def max_bond_block do initial_coins/epoch/signers_per_block end
  def signers_per_block do 100 end #12,000 in first 2 blocks
  def empty_account do [amount: 0, bond: 0, wait: {0, 0}, nonce: 0] end #wait={amount, height}
  def epoch do 50 end#amount of time until reveal
  def chances_per_address do 200 end #23,000 in first 2 blocks.
  def default_peers do [] end
end
defmodule DetHash do
  def hash(s) do :crypto.hmac(:sha256, to_string(s), "") |> Base.encode64 end
  def collect(l) do Enum.reduce(l, "", fn element, acc -> element<>acc end) end #list of strings -> string
  def hash_list(l) do 
    hash(collect(Enum.map(Enum.sort(l), fn x -> inspect(x) end))) end
  def hash_dict(s) do
    keys = Dict.keys(s)
    keys = Enum.sort(keys)
    values = Enum.map( keys, fn x -> elem(Dict.fetch(s, x), 1) end)
    hash_list( keys ++ values )
  end
  def doit(a) do
    cond do
      is_list(a) -> hash_list(a)
      is_tuple(a) -> hash_list(Tuple.to_list(a))
      is_integer(a) -> hash(a)
      is_float(a) -> hash(a)
      is_binary(a) -> hash(a)
      true -> hash_dict(a)
    end
  end
  def test() do IO.puts(doit([a: :b])) end
end

defmodule HashMath do
  def abc do ["0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "A": 10, "B": 11, "C": 12, "D": 13, "E": 14, "F": 15] end
  def helper(h, acc) do#this runs over 1000000 times in first 2 blocks.
    cond do
      h=="" -> acc
      true -> 
        a=String.slice(h, 0..0)
        b=String.slice(h, 1,10000)
        helper(b, acc*16+abc[String.to_atom(a)])
    end
  end
  def hex2int(h) do helper(h, 0) end
  def hash2int(h) do
    {:ok, h}=Base.decode64(h)
    h=Base.encode16(h)
    hex2int(h)
  end 
  def size(i, j \\ 0, base \\ 16) do
    cond do
      :math.pow(base, j) > i -> j-1
      true -> size(i, j+1)
    end
  end
  def pow(a, b) do
    b=f2i(b)
    cond do
      b==1 -> a
      rem(b, 2)==0 -> 
        pow(a*a, f2i(b/2))
      true -> a*pow(a, b-1)
    end
  end
  def f2i(f) do 
    {i, _}= :string.to_integer(to_char_list(to_string(f)))
  f2i(f, 0, i) end
  def f2i(f, lower, upper) do
    #IO.puts "upper lower f #{inspect upper}, #{inspect lower}, #{inspect f}"
    mid=div((lower+upper), 2)
    odd=rem((lower+upper), 2)
    cond do
      lower>=upper-1 -> 
        cond do
          f>mid -> upper
          true -> lower
      end
      f>mid -> f2i(f, mid+odd, upper)
      f<mid -> f2i(f, lower, mid)
    end
  end
  def to16(i, s) do
    ten=["10": "A", "11": "B", "12": "C", "13": "D", "14": "E", "15": "F"]
    p=pow(16, s)
    n=div(i, p)
    r=rem(i, p)
    rest = fn() -> to16(r, s-1) end
    f = fn(r) -> ten[String.to_atom(to_string(r))] end
    g = fn(n) -> to_string(n) end
    cond do
      s==1 -> 
        cond do
          n>9 -> f.(r)
          true -> g.(r)
        end
      n>9 -> f.(n)<>rest.()
      true -> g.(n)<>rest.()
    end
  end
  def int2hash(i) do 
    s=to16(i, size(i))  
    {:ok, s}=Base.decode16(s)
    Base.encode64(s)
  end
  def test do
    IO.puts hex2int("100")
    IO.puts hex2int("101")
    IO.puts DetHash.doit(2)
    IO.puts hash2int(DetHash.doit(2))
    #IO.puts inspect f2i(100.0)
    #IO.puts DetHash.doit(1)
    #IO.puts int2hash(hash2int(DetHash.doit(1)))
  end
end
#these variables can be different on every node
defmodule Keys do
  use GenServer
  def key do :address end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do {:ok, {"", ""}} end
  def handle_cast(:new, x) do {:noreply, Sign.new_key} end
  def handle_cast({:load, y, z}, x) do {:noreply, {y, z}} end
  def handle_call({:sign, m}, _from, x) do
    {pub, priv} = x
    sig=Sign.sign_tx(m, pub, priv)
    {:reply, sig, x}
  end
  def handle_call(:pubkey, _from, x) do {:reply, elem(x, 0), x} end
  def pubkey do GenServer.call(key, :pubkey) end
  def sign(m) do GenServer.call(key, {:sign, m}) end
  def new do GenServer.cast(key, :new) end
  def load(pub, priv) do GenServer.cast(key, {:load, pub, priv}) end
  def master do load("BCmhaRq42NNQe6ZpRHIvDxHBThEE3LDBN68KUWXmCTKUZvMI8Ol1g9yvDVTvMsZbqHQZ5j8E7sKVCgZMJR7lQWc=", "pRxnT/38wyd6lSbwfCEVvchAL7m7AMYuZeQKrJW/RO0=") end
end
defmodule KV do
  use GenServer
  def key do :kv end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do {:ok, HashDict.new} end
  def handle_call(:keys, _from, dict) do {:reply, Dict.keys(dict), dict} end
  def handle_call({:get, v}, _from, dict) do
    out = dict[v]
    if out == nil do out = Constants.empty_account end
    {:reply, out, dict}
  end
  def handle_cast({:put, k, v}, dict) do {:noreply, Dict.put(dict, k, v)} end
  def put(k, v) do GenServer.cast(key, {:put, k, v}) end
  def get(k) do GenServer.call(key, {:get, k}) end
  def keys do GenServer.call(key, :keys) end
end
defmodule Listener do
  use GenServer
  def key do :listen end
  def port do 6666 end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do {:ok, []} end#
  def handle_cast({type, s, args}, _) do 
    spawn_send(s, (fn() -> main(type, args) end))
    {:noreply, []}
  end
  def export(l) do 
    GenServer.cast(key, {hd(l), self(), tl(l)}) 
    receive do [:ok, x] -> x end
  end
  def main(type, args) do
    case type do
      "add_blocks" -> BlockAbsorber.absorb(hd(args))
      "pushtx" -> fee_filter(hd(args))
      "txs" -> Mempool.txs
      "height" -> KV.get("height")
      "block" -> Blockchain.get_block(hd(args))
      "blocks" -> flip(blocks(hd(args), hd(tl(args))))
      "add_peer" -> Peers.add_peer(hd(args))
      "all_peers" -> Peers.get_all
      "status" ->
          h = KV.get("height")
          block = Blockchain.get_block(h)
          if block[:data]==nil do block = [data: 1] end
          [height: h, hash: DetHash.doit(block[:data])]
      x -> IO.puts("is not a command #{inspect x}")
    end
  end
  def spawn_send(s, f) do
    spawn_link(fn() ->
      send s, [:ok, f.()]
    end)
  end
  def fee_filter(tx) do
    cond do
      tx[:data][:fee]<10000 -> "low-fee tx are blocked on this node"
      true -> Mempool.add_tx(tx)
    end
  end
  def flip(x, y \\ []) do 
    cond do
      x==[] -> y
      true -> flip(tl(x), [hd(x)|y])
    end
  end
  def max do 10000 end
  def blocks(start, finish, out \\ []) do
    finish = min(finish, KV.get("height"))
    blocks_helper(start, finish, out)
  end
  def blocks_helper(start, finish, out) do
    block = Blockchain.get_block(start)
    cond do
      byte_size(PackWrap.pack(out)) > max -> tl(out)
      start < 0 -> blocks(1, finish, out)
      start > finish -> out
      block == Constants.empty_account -> blocks_helper(start+1, finish, out)
      true -> blocks_helper(start+1, finish, [block|out])
    end
  end
end
defmodule Main do
  import Supervisor.Spec
  def start(n \\ 0) do
    p=n+Listener.port
    {x, socket} = Tcp.open(p)
    cond do
      x==:ok ->
        Tcp.close(socket)
        children = [ worker(KV, []),
                     worker(Keys, []),
                     worker(Mempool, []), 
                     worker(BlockAbsorber, []),                 
                     worker(Peers, []),                 
                     worker(Listener, []) ]
        {:ok, pid} = Supervisor.start_link(children, strategy: :rest_for_one)
        Tcp.start(p, &(Listener.export(&1)))
        {:ok, pid} = Supervisor.start_link([worker(Talker, [])], strategy: :one_for_one)
        KV.put("port", p)
        Peers.add_peer([ip: "localhost", port: p])
      true ->
        IO.puts("this port is already being used on this machine")
    end
  end
end
defmodule Mempool do
  use GenServer
  def key do :txs end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do {:ok, []} end
  def handle_cast(:dump, x) do {:noreply, []} end
  def handle_cast({:add_tx, tx}, x) do 
    h = KV.get("height")
    if h<1 do prev_hash=nil else 
    prev_hash = Blocktree.blockhash(BlockchainPure.get_block(h))
    end
  if VerifyTx.check_tx(tx, x, prev_hash) do x=[tx|x] end
  {:noreply, x}
  end
  def handle_call(:txs, _from, x) do {:reply, x, x} end
  def dump do GenServer.cast(key, :dump) end
  def add_tx(tx) do GenServer.cast(key, {:add_tx, tx}) end
  def txs do GenServer.call(key, :txs) end
end
#contains all modules from MessagePack library
defmodule MessagePack.Unpacker do
  @spec unpack(binary) :: { :ok, term } | { :error, term }
  @spec unpack(binary, Keyword.t) :: { :ok, term } | { :error, term }
  def unpack(binary, options \\ []) when is_binary(binary) do
    options = parse_options(options)

    case do_unpack(binary, options) do
      { :error, _ } = error ->
        error
      { result, "" } ->
        { :ok, result }
      { _, bin } when is_binary(bin) ->
        { :error, :not_just_binary }
    end
  end

  @spec unpack!(binary) :: term | no_return
  @spec unpack!(binary, Keyword.t) :: term | no_return
  def unpack!(binary, options \\ []) when is_binary(binary) do
    case unpack(binary, options) do
      { :ok, result } ->
        result
      { :error, error } ->
        raise ArgumentError, message: inspect(error)
    end
  end

  @spec unpack(binary) :: { :ok, { term, binary } } | { :error, term }
  @spec unpack(binary, Keyword.t) :: { :ok, { term, binary } } | { :error, term }
  def unpack_once(binary, options \\ []) when is_binary(binary) do
    options = parse_options(options)

    case do_unpack(binary, options) do
      { :error, _ } = error ->
        error
      result ->
        { :ok, result }
    end
  end

  @spec unpack!(binary) :: { term, binary } | no_return
  @spec unpack!(binary, Keyword.t) :: { term, binary } | no_return
  def unpack_once!(binary, options \\ []) when is_binary(binary) do
    case unpack_once(binary, options) do
      { :ok, result } ->
        result
      { :error, error } ->
        raise ArgumentError, message: inspect(error)
    end
  end

  defp parse_options(options) do
    enable_string = !!options[:enable_string]

    { packer, unpacker } = case options[:ext] do
      nil ->
        { nil, nil }
      mod when is_atom(mod) ->
        { &mod.pack/1, &mod.unpack/2 }
      list when is_list(list) ->
        { list[:packer], list[:unpacker] }
    end

    %{enable_string: enable_string, ext_packer: packer, ext_unpacker: unpacker}
  end

  # positive fixnum
  defp do_unpack(<< 0 :: 1, v :: 7, rest :: binary >>, _), do: { v, rest }

  # negative fixnum
  defp do_unpack(<< 0b111 :: 3, v :: 5, rest :: binary >>, _), do: { v - 0b100000, rest }

  # uint
  defp do_unpack(<< 0xCC, uint :: 8-unsigned-integer, rest :: binary >>, _), do: { uint, rest }
  defp do_unpack(<< 0xCD, uint :: 16-big-unsigned-integer-unit(1), rest :: binary >>, _), do: { uint, rest }
  defp do_unpack(<< 0xCE, uint :: 32-big-unsigned-integer-unit(1), rest :: binary >>, _), do: { uint, rest }
  defp do_unpack(<< 0xCF, uint :: 64-big-unsigned-integer-unit(1), rest :: binary >>, _), do: { uint, rest }

  # int
  defp do_unpack(<< 0xD0, int :: 8-signed-integer, rest :: binary >>, _), do: { int, rest }
  defp do_unpack(<< 0xD1, int :: 16-big-signed-integer-unit(1), rest :: binary >>, _), do: { int, rest }
  defp do_unpack(<< 0xD2, int :: 32-big-signed-integer-unit(1), rest :: binary >>, _), do: { int, rest }
  defp do_unpack(<< 0xD3, int :: 64-big-signed-integer-unit(1), rest :: binary >>, _), do: { int, rest }

  # nil
  defp do_unpack(<< 0xC0, rest :: binary >>, _), do: { nil, rest }

  # boolean
  defp do_unpack(<< 0xC2, rest :: binary >>, _), do: { false, rest }
  defp do_unpack(<< 0xC3, rest :: binary >>, _), do: { true, rest }

  # float
  defp do_unpack(<< 0xCA, float :: 32-float-unit(1), rest :: binary >>, _), do: { float, rest }
  defp do_unpack(<< 0xCB, float :: 64-float-unit(1), rest :: binary >>, _), do: { float, rest }

  # old row format
  defp do_unpack(<< 0b101 :: 3, len :: 5, binary :: size(len)-binary, rest :: binary >>, %{enable_string: false}), do: { binary, rest }
  defp do_unpack(<< 0xDA, len :: 16-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, %{enable_string: false}), do: { binary, rest }
  defp do_unpack(<< 0xDB, len :: 32-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, %{enable_string: false}), do: { binary, rest }

  # string
  defp do_unpack(<< 0b101 :: 3, len :: 5, binary :: size(len)-binary, rest :: binary >>, %{enable_string: true}) do
    if String.valid?(binary) do
      { binary, rest }
    else
      { :error, { :invalid_string, binary } }
    end
  end
  defp do_unpack(<< 0xD9, len :: 8-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, %{enable_string: true}) do
    if String.valid?(binary) do
      { binary, rest }
    else
      { :error, { :invalid_string, binary } }
    end
  end
  defp do_unpack(<< 0xDA, len :: 16-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, %{enable_string: true}) do
    if String.valid?(binary) do
      { binary, rest }
    else
      { :error, { :invalid_string, binary } }
    end
  end
  defp do_unpack(<< 0xDB, len :: 32-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, %{enable_string: true}) do
    if String.valid?(binary) do
      { binary, rest }
    else
      { :error, { :invalid_string, binary } }
    end
  end

  # binary
  defp do_unpack(<< 0xC4, len :: 8-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, _), do: { binary, rest }
  defp do_unpack(<< 0xC5, len :: 16-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, _), do: { binary, rest }
  defp do_unpack(<< 0xC6, len :: 32-unsigned-integer-unit(1), binary :: size(len)-binary, rest :: binary >>, _), do: { binary, rest }

  # array
  defp do_unpack(<< 0b1001 :: 4, len :: 4, rest :: binary >>, options), do: unpack_array(rest, len, options)
  defp do_unpack(<< 0xDC, len :: 16-big-unsigned-integer-unit(1), rest :: binary >>, options), do: unpack_array(rest, len, options)
  defp do_unpack(<< 0xDD, len :: 32-big-unsigned-integer-unit(1), rest :: binary >>, options), do: unpack_array(rest, len, options)

  # map
  defp do_unpack(<< 0b1000 :: 4, len :: 4, rest :: binary >>, options), do: unpack_map(rest, len, options)
  defp do_unpack(<< 0xDE, len :: 16-big-unsigned-integer-unit(1), rest :: binary >>, options), do: unpack_map(rest, len, options)
  defp do_unpack(<< 0xDF, len :: 32-big-unsigned-integer-unit(1), rest :: binary >>, options), do: unpack_map(rest, len, options)

  defp do_unpack(<< 0xD4, type :: 8, data :: 1-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xD5, type :: 8, data :: 2-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xD6, type :: 8, data :: 4-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xD7, type :: 8, data :: 8-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xD8, type :: 8, data :: 16-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xC7, len :: 8-unsigned-integer-unit(1), type :: 8, data :: size(len)-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xC8, len :: 16-big-unsigned-integer-unit(1), type :: 8, data :: size(len)-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end
  defp do_unpack(<< 0xC9, len :: 32-big-unsigned-integer-unit(1), type :: 8, data :: size(len)-binary, rest :: binary >>, %{ext_unpacker: unpacker}) do
    unpack_ext(unpacker, type, data, rest)
  end

  # invalid prefix
  defp do_unpack(<< 0xC1, _ :: binary >>, _), do: { :error, { :invalid_prefix, 0xC1 } }

  defp do_unpack(_, _), do: { :error, :incomplete }

  defp unpack_array(binary, len, options) do
    do_unpack_array(binary, len, [], options)
  end

  defp do_unpack_array(rest, 0, acc, _) do
    { :lists.reverse(acc), rest }
  end

  defp do_unpack_array(binary, len, acc, options) do
    case do_unpack(binary, options) do
      { :error, _ } = error ->
        error
      { term, rest } ->
        do_unpack_array(rest, len - 1, [term|acc], options)
    end
  end

  defp unpack_map(binary, 0, _) do
    { [{}], binary }
  end

  defp unpack_map(binary, len, options) do
    do_unpack_map(binary, len, [], options)
  end

  defp do_unpack_map(rest, 0, acc, _) do
    { :lists.reverse(acc), rest }
  end

  defp do_unpack_map(binary, len, acc, options) do
    case do_unpack(binary, options) do
      { :error, _ } = error ->
        error
      { key, rest } ->
        case do_unpack(rest, options) do
          { :error, _ } = error ->
            error
          { value, rest } ->
            do_unpack_map(rest, len - 1, [{key, value}|acc], options)
        end
    end
  end

  def unpack_ext(nil, _, _, _), do: { :error, :undefined_ext }
  def unpack_ext(unpacker, type, data, rest) when is_function(unpacker) do
    case unpacker.(type, data) do
      { :ok, term } ->
        { term, rest }
      { :error, _ } = error ->
        error
    end
  end
end
defmodule MessagePack.Ext do

  use Behaviour

  @type type :: non_neg_integer
 
  defcallback pack(term) :: { :ok, { type, binary } } | { :error, term }
  defcallback unpack(type, binary) :: { :ok, term } | { :error, term }

  defmodule Behaviour do
    defmacro __using__(_) do
      quote do
        @behaviour MessagePack.Ext
      end
    end
  end
end
defmodule MessagePack do
  defdelegate pack(term), to: MessagePack.Packer
  defdelegate pack(term, options), to: MessagePack.Packer
  defdelegate pack!(term), to: MessagePack.Packer
  defdelegate pack!(term, options), to: MessagePack.Packer

  defdelegate unpack(term), to: MessagePack.Unpacker
  defdelegate unpack(term, options), to: MessagePack.Unpacker
  defdelegate unpack!(term), to: MessagePack.Unpacker
  defdelegate unpack!(term, options), to: MessagePack.Unpacker

  defdelegate unpack_once(term), to: MessagePack.Unpacker
  defdelegate unpack_once(term, options), to: MessagePack.Unpacker
  defdelegate unpack_once!(term), to: MessagePack.Unpacker
  defdelegate unpack_once!(term, options), to: MessagePack.Unpacker
end
defmodule MessagePack.Packer do
  @spec pack(term) :: { :ok, binary } | { :error, term }
  @spec pack(term, Keyword.t) :: { :ok, binary } | { :error, term }
  def pack(term, options \\ []) do
    options = parse_options(options)

    case do_pack(term, options) do
      { :error, _ } = error ->
        error
      packed ->
        { :ok, packed }
    end
  end

  @spec pack!(term) :: binary | no_return
  @spec pack!(term, Keyword.t) :: binary | no_return
  def pack!(term, options \\ []) do
    case pack(term, options) do
      { :ok, packed } ->
        packed
      { :error, error } ->
        raise ArgumentError, message: inspect(error)
    end
  end

  defp parse_options(options) do
    enable_string = !!options[:enable_string]

    {packer, unpacker} = case options[:ext] do
      nil ->
        { nil, nil }
      mod when is_atom(mod) ->
        { &mod.pack/1, &mod.unpack/2 }
      list when is_list(list) ->
        { list[:packer], list[:unpacker] }
    end

    %{enable_string: enable_string, ext_packer: packer, ext_unpacker: unpacker}
  end

  defp do_pack(nil, _),   do: << 0xC0 :: size(8) >>
  defp do_pack(false, _), do: << 0xC2 :: size(8) >>
  defp do_pack(true, _),  do: << 0xC3 :: size(8) >>
  defp do_pack(atom, options) when is_atom(atom), do: do_pack(Atom.to_string(atom), options)
  defp do_pack(i, _) when is_integer(i) and i < 0, do: pack_int(i)
  defp do_pack(i, _) when is_integer(i), do: pack_uint(i)
  defp do_pack(f, _) when is_float(f), do: << 0xCB :: size(8), f :: size(64)-big-float-unit(1)>>
  defp do_pack(binary, %{enable_string: true}) when is_binary(binary) do
    if String.valid?(binary) do
      pack_string(binary)
    else
      pack_bin(binary)
    end
  end
  defp do_pack(binary, _) when is_binary(binary), do: pack_raw(binary)
  defp do_pack(list, options) when is_list(list) do
    if map?(list) do
      pack_map(list, options)
    else
      pack_array(list, options)
    end
  end
  defp do_pack(term, %{ext_packer: packer}) when is_function(packer) do
    case pack_ext(term, packer) do
      { :ok, packed } -> packed
      { :error, _ } = error -> error
    end
  end
  defp do_pack(term, _), do: { :error, { :badarg, term } }

  defp pack_int(i) when i >= -32,                  do: << 0b111 :: 3, i :: 5 >>
  defp pack_int(i) when i >= -128,                 do: << 0xD0  :: 8, i :: 8-big-signed-integer-unit(1) >>
  defp pack_int(i) when i >= -0x8000,              do: << 0xD1  :: 8, i :: 16-big-signed-integer-unit(1) >>
  defp pack_int(i) when i >= -0x80000000,          do: << 0xD2  :: 8, i :: 32-big-signed-integer-unit(1) >>
  defp pack_int(i) when i >= -0x8000000000000000 , do: << 0xD3  :: 8, i :: 64-big-signed-integer-unit(1) >>
  defp pack_int(i), do: { :error, { :too_big, i } }

  defp pack_uint(i) when i < 0x80,                do: << 0    :: 1, i :: 7 >>
  defp pack_uint(i) when i < 0x100,               do: << 0xCC :: 8, i :: 8 >>
  defp pack_uint(i) when i < 0x10000,             do: << 0xCD :: 8, i :: 16-big-unsigned-integer-unit(1) >>
  defp pack_uint(i) when i < 0x100000000,         do: << 0xCE :: 8, i :: 32-big-unsigned-integer-unit(1) >>
  defp pack_uint(i) when i < 0x10000000000000000, do: << 0xCF :: 8, i :: 64-big-unsigned-integer-unit(1) >>
  defp pack_uint(i), do: { :error, { :too_big, i } }

  # for old row format
  defp pack_raw(binary) when byte_size(binary) < 32 do
    << 0b101 :: 3, byte_size(binary) :: 5, binary :: binary >>
  end
  defp pack_raw(binary) when byte_size(binary) < 0x10000 do
    << 0xDA  :: 8, byte_size(binary) :: 16-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_raw(binary) when byte_size(binary) < 0x100000000 do
    << 0xDB  :: 8, byte_size(binary) :: 32-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_raw(binary), do: { :error, { :too_big, binary } }

  # for string format
  defp pack_string(binary) when byte_size(binary) < 32 do
    << 0b101 :: 3, byte_size(binary) :: 5, binary :: binary >>
  end
  defp pack_string(binary) when byte_size(binary) < 0x100 do
    << 0xD9  :: 8, byte_size(binary) :: 8-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_string(binary) when byte_size(binary) < 0x10000 do
    << 0xDA  :: 8, byte_size(binary) :: 16-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_string(binary) when byte_size(binary) < 0x100000000 do
    << 0xDB  :: 8, byte_size(binary) :: 32-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_string(binary), do: { :error, { :too_big, binary } }

  # for binary format
  defp pack_bin(binary) when byte_size(binary) < 0x100 do
    << 0xC4  :: 8, byte_size(binary) :: 8-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_bin(binary) when byte_size(binary) < 0x10000 do
    << 0xC5  :: 8, byte_size(binary) :: 16-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_bin(binary) when byte_size(binary) < 0x100000000 do
    << 0xC6  :: 8, byte_size(binary) :: 32-big-unsigned-integer-unit(1), binary :: binary >>
  end
  defp pack_bin(binary) do
    { :error, { :too_big, binary } }
  end

  defp pack_map([{}], options), do: pack_map([], options)
  defp pack_map(map, options) do
    case do_pack_map(map, options) do
      { :ok, binary } ->
        case length(map) do
          len when len < 16 ->
            << 0b1000 :: 4, len :: 4-integer-unit(1), binary :: binary >>
          len when len < 0x10000 ->
            << 0xDE :: 8, len :: 16-big-unsigned-integer-unit(1), binary :: binary>>
          len when len < 0x100000000 ->
            << 0xDF :: 8, len :: 32-big-unsigned-integer-unit(1), binary :: binary>>
          _ ->
            { :error, { :too_big, map } }
        end
      error ->
        error
    end
  end

  defp pack_array(list, options) do
    case do_pack_array(list, options) do
      { :ok, binary } ->
        case length(list) do
          len when len < 16 ->
            << 0b1001 :: 4, len :: 4-integer-unit(1), binary :: binary >>
          len when len < 0x10000 ->
            << 0xDC :: 8, len :: 16-big-unsigned-integer-unit(1), binary :: binary >>
          len when len < 0x100000000 ->
            << 0xDD :: 8, len :: 32-big-unsigned-integer-unit(1), binary :: binary >>
          _ ->
            { :error, { :too_big, list } }
        end
      error ->
        error
    end
  end

  def do_pack_map(map, options) do
    do_pack_map(:lists.reverse(map), <<>>, options)
  end

  defp do_pack_map([], acc, _), do: { :ok, acc }
  defp do_pack_map([{ k, v }|t], acc, options) do
    case do_pack(k, options) do
      { :error, _ } = error ->
        error
      k ->
        case do_pack(v, options) do
          { :error, _ } = error ->
            error
          v ->
            do_pack_map(t, << k :: binary, v :: binary, acc :: binary >>, options)
        end
    end
  end

  defp do_pack_array(list, options) do
    do_pack_array(:lists.reverse(list), <<>>, options)
  end

  defp do_pack_array([], acc, _), do: { :ok, acc }
  defp do_pack_array([h|t], acc, options) do
    case do_pack(h, options) do
      { :error, _ } = error ->
        error
      binary ->
        do_pack_array(t, << binary :: binary, acc :: binary >>, options)
    end
  end

  defp map?([]), do: false
  defp map?([{}]), do: true
  defp map?(list) when is_list(list), do: :lists.all(&(match?({_, _}, &1)), list)
  defp map?(_), do: false

  defp pack_ext(term, packer) do
    case packer.(term) do
      { :ok, { type, data } } when 0 < type and type < 0x100 and is_binary(data) ->
        maybe_bin = case byte_size(data) do
                      1 -> << 0xD4, type :: 8, data :: binary >>
                      2 -> << 0xD5, type :: 8, data :: binary >>
                      4 -> << 0xD6, type :: 8, data :: binary >>
                      8 -> << 0xD7, type :: 8, data :: binary >>
                      16 -> << 0xD8, type :: 8, data :: binary >>
                      size when size < 0x100 ->
                        << 0xC7, size :: 8, type :: 8, data :: binary >>
                      size when size < 0x10000 ->
                        << 0xC8, size :: 16, type :: 8, data :: binary >>
                      size when size < 0x100000000 ->
                        << 0xC9, size :: 32, type :: 8, data :: binary >>
                      _ ->
                        { :error, { :too_big, data } }
                    end
        case maybe_bin do
          { :error, _ } = error ->
            error
          bin ->
            { :ok, bin }
        end
      { :ok, other } ->
        { :error, { :invalid_ext_data, other } }
      { :error, _ } = error ->
        error
    end
  end
end
defmodule PackWrap do
  def pack(x) do MessagePack.pack!(x) end
  def slow_get(json, key) do#16,000 times in first 2 blocks.
    cond do
      json == [] -> nil
      true ->
        [{a, b}|tail]=json
        cond do
          a==key -> b
          true -> slow_get(tail, key)
        end
    end
  end
  def rekey(json) do
    cond do
      not is_list(json) or json==[] -> json
      is_tuple(hd(json))->
        Enum.map(Dict.keys(json), fn(k) ->
          {String.to_atom(k), rekey(slow_get(json, k))}
        end)
      true -> Enum.map(json, &(rekey(&1)))
    end
  end
  def unpack(x) do rekey(MessagePack.unpack!(x)) end
  def test do
    x=unpack(pack([meta: :b]))
    IO.puts inspect x
  end
end

defmodule Peers do#this module is a database of who your peers are, and other data useful for networking that isn't under consensus.
  use GenServer
  def key do :peers end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do {:ok, []} end
  def handle_call(:get_all, _from, mem) do {:reply, mem, mem} end
  def handle_call({:get, peer}, _from, mem) do {:reply, Dict.get(mem, peer_key(peer)), mem} end
  def handle_cast({:update, peer}, mem) do 
    b=Dict.put(mem, peer_key(peer), peer)
    {:noreply, b} 
  end
  def peer_key(peer) do String.to_atom(to_string(peer[:port]) <>"$"<> peer[:ip]) end#to atom is VERY DANGEROUS!!!
  def get_all do GenServer.call(key, :get_all) end
  def get(peer) do GenServer.call(key, {:get, peer}) end
  def timestamp do 
    {_, b, c} = :os.timestamp
    b*1000+div(c, 1000)
  end
  def update(peer, height, hash) do
    p = peer |> Dict.put(:time, timestamp) |> Dict.put(:height, height) |> Dict.put(:hash, hash) 
    GenServer.cast(key, {:update, p})
  end
  def new_peer(peer) do update(peer, 0, "") end
  def add_peer(peer) do 
  cond do
    is_binary(peer) -> false
    is_integer(peer) -> false
    peer_key(peer) in Dict.keys(get_all) -> false
    true -> new_peer(peer)
    end
  end
end
defmodule Sign do
  def params do
    :crypto.ec_curve(:secp256k1)
  end
  def new_key do
    {pub, priv}=:crypto.generate_key(:ecdh, params)
    pub=Base.encode64(pub)
    priv=Base.encode64(priv)
    {pub, priv}
  end
  def sign(s, priv) do
    {:ok, priv} = Base.decode64(priv)
    :crypto.sign(:ecdsa, :sha256, s, [priv, params]) |>
      Base.encode64
  end
  def verify(s, sig, pub) do
    {:ok, sig} = Base.decode64(sig)
    {:ok, pub} = Base.decode64(pub)
    :crypto.verify(:ecdsa, :sha256, s, sig, [pub, params])
  end
  def sign_tx(tx, pub, priv) do
    h=DetHash.doit(tx)
    sig=sign(h, priv)
    [pub: pub, sig: sig, data: tx, meta: []]
  end
  def verify_tx(signed_tx) do
    h=DetHash.doit(signed_tx[:data])
    verify(h, signed_tx[:sig], signed_tx[:pub])
  end
  def test do
    {pub, priv}=new_key
    tx=[a: "b", b: "c"]
    tx=sign_tx(tx, pub, priv) 
    true=verify_tx(tx)
    s="test string"
    sig=sign(s, priv)
    true=verify(s, sig, pub)
    false=verify(s<>" ", sig, pub)
    "success"
  end
end
defmodule Talker do
  use GenServer
  def key do :talker end
  def start_link() do GenServer.start_link(__MODULE__, :ok, [name: key]) end
  def init(:ok) do 
    start
    Enum.map(0..2, &([ip: "localhost", port: 6666+&1])) |> Enum.map(&(Peers.add_peer(&1)))
    {:ok, []} 
  end
  def handle_cast(:doit, _) do 
    check_peers    
    {:noreply, []} 
  end
  def doit do GenServer.cast(key, :doit) end
  def timer do
    :timer.sleep(3000)#using a timer to stop crash on boot
    doit
    timer
  end  
  def start do spawn_link(fn() -> timer end) end
  #this module creates and maintains connections with multiple peers. It downloads blocks from them.
  #grabs the list of peers from peers thread.
  #has ability to black-list peers who are bad?
  #never talks to peers more often than a minimum.
  #don't ignore any peer much longer than the others.
  #download blocks and peers.
  def add_peers(x) do Enum.map(x, fn(x) -> Peers.add_peer(x) end) end
  def still_on(blocks) do blocks == :ok or blocks == [] or (is_tuple(hd(blocks)) and :error in Dict.keys(blocks)) end
  def download(n, i, p, out \\ []) do
    lo = length(out)
    cond do
      lo >= n -> out
      true -> 
        out = out++Api.blocks(i+lo, i+n, p[:port], p[:ip])
        download(n-1, i, p, out)
    end
  end
  def download_blocks(i, u, p) do
    blocks = download(min(50, u-i), i, p)
    my_block=Api.blocks(i, i)
    cond do
      my_block == [] ->
        BlockAbsorber.absorb(blocks)
        [status: :first_blocks]
      still_on(my_block) -> IO.puts("thread died")
      still_on(blocks) -> IO.puts("peer died 0")
      hd(my_block)[:data][:hash] == hd(blocks)[:data][:hash] ->
        BlockAbsorber.absorb(blocks)
        [status: :ahead]
      true -> 
        blocks = download(50, max(0, i-40), p)
        BlockAbsorber.absorb(blocks)
        [status: :fork, height: u, peer: p]
    end
  end
  def trade_peers(p) do
    my_peers = Api.all_peers
    peers = Api.all_peers(p[:port], p[:ip])
    if my_peers == :ok or peers == :ok do
      IO.puts("peer died 1")
    else
      not_yours = Enum.filter(my_peers, &(not &1 in peers))
      not_mine = Enum.filter(peers, &(not &1 in my_peers))
      Enum.map(not_yours,&(Api.add_peer(elem(&1, 1),p[:port],p[:ip])))
      Enum.map(not_mine, &(Peers.add_peer(elem(&1, 1))))
    end
  end
  def check_peer(p) do #validating mode
    status = Api.status(p[:port], p[:ip])
    cond do
      status == :ok or status == "ok"-> IO.puts("peer died 2")
      :error in Dict.keys(status) ->
        status[:error]
      true -> 
        Peers.get(p) |> Dict.put(:height, status[:height]) |> Dict.put(:hash, status[:hash]) |> Peers.add_peer
        check_peer_2(p, status)
    end
  end
  def check_peer_2(p, status) do
    trade_peers(p)
    txs=Api.txs(p[:port], p[:ip])
    u=status[:height]
    i=KV.get("height")
    cond do
      txs == :ok -> IO.puts("txs shouldn't be :ok")
      (txs != []) and length(txs)>0 and is_tuple(hd(txs)) -> 
        IO.puts("tx error #{inspect txs}")
      u>i -> download_blocks(i, u, p)
      u==i -> Enum.map(txs, &(Mempool.add_tx(&1)))
      true ->
        IO.puts("im ahead")
        true
    end
  end
  def check_peers do
    Peers.get_all 
    |> Enum.map(&(elem(&1,1))) 
    |> Enum.map(&(spawn_link(fn -> check_peer(&1) end)))
   end
end
defmodule Tcp do
  def open(port) do :gen_tcp.listen(port, [:binary, {:packet, 0}, {:active, false}]) end
  def close(socket) do :gen_tcp.close(socket) end
  def start(port, func) do
    {:ok, socket} = open(port)
    spawn_link(fn -> new_peer(socket, port, func) end)
  end
  defp connect(host, port) do
    {x, s} = :gen_tcp.connect(:erlang.binary_to_list(host), port, [{:active, false}, {:packet, 0}])
    cond do
      x==:ok -> s
      true -> "error"
    end
  end
  defp new_peer(socket, port, func) do
    {x, conn} = :gen_tcp.accept(socket)
    if x==:ok do
      spawn_link(fn -> :timer.sleep(10)
                       new_peer(socket, port, func) end)
      conn |> listen |> func.() |> ms(conn) #these threads need a timer or something to kill them, otherwise we end up having too many.
    else
      IO.puts "failed to connect #{inspect conn}" 
      close(socket)
      :timer.sleep(500)
      spawn_link(fn -> start(port, func) end)
    end
  end
  defp ms(string, socket) do
    if is_pid(string) do
      true=false
    end
    m=PackWrap.pack(string)
    s=byte_size(m)
    a=<<s::size(32)>>
    :gen_tcp.send(socket, a <> m)
  end
  def talk(host, port, msg) do
    s=connect(host, port)
    if s=="error" do
      {:error, "peer is off"}
    else
      case ms(msg, s) do
        :ok -> {:ok, listen(s, "")}
        x -> {:error, x}
      end
    end
  end
  def ping(host, port) do
    s=connect(host, port)
    ms("ping", s)
  end
  defp to_bytes(list) do#141,000 times in first 2 blocks
    cond do
      is_binary(list) -> list
      list==[] -> <<>>
      true -> <<hd(list)>> <> to_bytes(tl(list))
    end
  end
  defp listen(conn, data \\ "") do
   case :gen_tcp.recv(conn, 0) do
      {:ok, d} ->
        done_listening?(conn, data<>to_bytes(d))
      {:error, :closed} ->
        IO.puts "error"
    end
  end
  defp done(data) do
    cond do
      byte_size(data)<4 -> false
      true ->
        <<a::size(32), b::binary>>=data
        cond do
          byte_size(b)==a -> true
          true -> false
        end
    end
  end
  defp done_listening?(conn, data) do
    cond do
      done(data) -> 
        <<_::size(32), data::binary>> = data
        PackWrap.unpack(data)
      true -> listen(conn, data)
    end
  end
  def test do
    port=6666
    start(port, &(&1))
    IO.puts(inspect talk("localhost", port, [a: [b: 3, d: "e"]]))
  end
end
defmodule TxCreator do
  def nonce(pub) do 
    a=Mempool.txs |> Enum.filter(fn(tx) -> tx[:pub]==pub end) |> length
    a+KV.get(pub)[:nonce] 
  end
  def spend(amount, to) do
    pub = Keys.pubkey
    balance = KV.get(pub)[:amount]
    if balance<amount do IO.puts("warning, you cannot afford to spend this tx, so it wont be valid") end
    tx=[type: "spend", to: to, amount: amount, nonce: nonce(pub), fee: 10000]
    tx = Keys.sign(tx)
    Mempool.add_tx(tx)    
  end
  def sign do
    pub = Keys.pubkey
    acc = KV.get(pub)
    if acc[:bond] > Constants.minbond do
      h=KV.get("height")
      if h<1 do prev_hash=nil else
        prev_hash = Blocktree.blockhash(Blockchain.get_block(h))
      end
      tot_bonds = KV.get("tot_bonds")
      w=Enum.filter(0..Constants.chances_per_address, fn(x) -> VerifyTx.winner?(acc[:bond], tot_bonds, VerifyTx.rng(prev_hash), pub, x) end) 
      h=KV.get("height")+1
      ran = KV.get("secret #{inspect h}")
      if ran == Constants.empty_account do
        ran=:crypto.rand_bytes(10)
        KV.put("secret #{inspect h}", ran)
      end
      secret=DetHash.doit(ran)
      tx = [type: "sign", prev_hash: prev_hash, winners: w, secret_hash: secret, nonce: nonce(pub)]
      tx = Keys.sign(tx)
      Mempool.add_tx(tx)
    end
  end
  def reveal do
    h=KV.get("height")-Constants.epoch
    cond do
      h<1 -> nil
      true ->
        reveal_2(h)
    end
  end
  def reveal_2(h) do
    pub = Keys.pubkey
    old_block=Blockchain.get_block(h)
    old_tx = old_block[:data][:txs] |> Enum.filter(&(&1[:data][:type]=="sign")) |> Enum.filter(&(&1[:pub]==pub)) |> hd
    w=old_tx[:data][:winners]
    bond_size=old_block[:data][:bond_size]
    secret = KV.get("secret #{inspect h}")
    if secret != Constants.empty_account do
      tx=[type: "reveal", signed_on: h, winners: w, amount: length(w)*bond_size, secret: KV.get("secret #{inspect h}"), nonce: nonce(pub)]
      tx = Keys.sign(tx)
      Mempool.add_tx(tx)
    end
  end  
end
defmodule TxUpdate do
  #d is 1 when adding blocks, -1 when removing.
  def exchange_rate(n \\ 0) do#how many bonds is a cash worth?
    b=KV.get("height")-n
    :math.pow(1.001, b)
  end  
  def sym_replace(pub, key, old, new, d) do
    acc=KV.get(pub)
    cond do
      d==1 -> word=new
      d==-1 -> word=old
    end
    KV.put(pub, Dict.put(acc, key, word))
  end    
  def sym_increment(pub, key, amount, d) do
    acc=KV.get(pub)
    acc=Dict.put(acc, key, acc[key]+(amount*d))
    KV.put(pub, acc)
  end
  def deep_get(dict, keys) do
    cond do
      keys==[] -> dict
      true -> deep_get(dict[hd(keys)], tl(keys))
    end
  end
  def deep_put(dict, keys, val) do
    cond do
      keys==[] -> val
      true -> Dict.put(dict, hd(keys), deep_put(dict[hd(keys)], tl(keys), val))
    end
  end
  def sym_append(pub, keys, item, d) do
    acc=KV.get(pub)
    a=deep_get(acc, keys)
    cond do
      d ==  1 -> a=a++[item]
      d == -1 -> a=a--[item]
    end
    acc=deep_put(acc, keys, a)
    KV.put(pub, acc)
  end
  def spend(tx, d) do
    sym_increment(tx[:pub], :amount, -tx[:data][:amount]-tx[:data][:fee], d)
    sym_increment(tx[:data][:to], :amount, tx[:data][:amount], d)
  end
  def spend2wait(tx, d) do
    #can only have 1 wait-money at a time.
    h=KV.get("height")
    sym_increment(tx[:pub], :amount, -tx[:data][:amount]-tx[:data][:fee], d)
    sym_replace(tx[:pub], :wait, {0,0}, {tx[:data][:amount], h}, d)
  end
  def wait2bond(tx, d) do
    {a, h}=tx[:data][:wait_money]
    b=KV.get("tot_bonds")
    KV.put("tot_bonds", b+(a*exchange_rate*d))
    sym_increment(tx[:pub], :bond, a*exchange_rate, d)
    sym_replace(tx[:pub], :wait, {a, h}, {0,0}, d)
    #If a user wants to take part in the consensus process, they would use this transaction type to turn some of their wait-money into bond-money. The price for bond-money changes continuously over time, and more bond-money is printed and given to the people who participate. If you participate, then the value of your bond-money will slowly grow. If you dont participate, then the value will quickly shrink. 
    #There is a minimum size for purchasing bond-money, priced in spend-money. 
  end
  def bond2spend(tx, d) do
    a=tx[:data][:amount]
    b=KV.get("tot_bonds")
    KV.put("tot_bonds", b-(a*d))
    sym_increment(tx[:pub], :amount, a/exchange_rate-tx[:data][:fee], d)
    sym_increment(tx[:pub], :bond, -a, d)
    #Users can take their money out of the bond at any time. 
  end
  def sign(tx, d, bond_size) do#0.1% of total bonds is given out as rewards on every block, which changes the exchange rate.
    w=length(tx[:data][:winners])
    delta=-exchange_rate*bond_size*w
    b=KV.get("tot_bonds")
    KV.put("tot_bonds", b+delta*d)
    sym_increment(tx[:pub], :bond, delta, d)
    #loses some :bond money. total_money
    #The most they could have to pay is as much bond-money as the poorest of them has.
  end
  def slasher(tx, d) do
    #If you can prove that the same address signed on 2 different blocks at the same height, then you can take 1/3rd of the deposit, and destroy the rest.
  end
  def reveal(tx, d) do
    #lets change old_block somehow so that you cannot reveal the same secret twice.
    old_block=VerifyTx.signed_block(tx)
    bond_size=old_block[:data][:bond_size]
    w=length(tx[:data][:winners])
    delta=exchange_rate(old_block[:data][:height])*bond_size*w
    reward=KV.get("tot_bonds")/:math.pow(1.001, Constants.epoch)*w/1000/Constants.signers_per_block
    IO.puts("kv #{inspect KV.get(to_string(tx[:data][:signed_on]))}")
    IO.puts("tx #{inspect tx}")
    sym_append(KV.get(to_string(tx[:data][:signed_on])), [:meta, :revealed], tx[:pub], d)
    sym_increment(tx[:pub], :amount, tx[:data][:amount]+reward+delta, d)#during waiting period you are holding cash not bonds.
    #After you sign, you wait a while, and eventually are able to make this tx. This tx reveals the random entropy_bit and salt from the sign tx, and it reclaims the safety deposit given in the sign tx. If your bit is in the minority, then your prize is bigger.
  end
  def tx_update(tx, d, bond_size) do
    acc=KV.get(tx[:pub])
    acc=Dict.put(acc, :nonce, acc[:nonce]+1*d)
    KV.put(tx[:pub], acc)
    case Dict.get(tx[:data], :type) do
      "spend" ->      spend(tx, d)
      "spend2wait" -> spend2wait(tx, d)
      "wait2bond" ->  wait2bond(tx, d)
      "bond2spend" -> bond2spend(tx, d)
      "sign" ->       sign(tx, d, bond_size)
      "slasher" ->    slasher(tx, d)
      "reveal" ->     reveal(tx, d)
      _	->            false			
    end
  end
  def txs_updates(txs, d, bond_size) do
    Enum.map(txs, &(tx_update(&1, d, bond_size)))
  end
end

defmodule VerifyBalances do
  def all_positive(a) do
    cond do
      a==[] -> true
      true -> all_positive_1(a)
    end
  end
  def all_positive_1(addresses) do
    [{_, t}|tail] = addresses
    cond do
      t<0 -> false
      tail==[] -> true
      true -> all_positive_1(tail)
    end
  end
  def modify_balance(addresses, pub, f) do
    key = String.to_atom(pub)
    balance=Dict.get(addresses, key)
    balance=f.(balance)
    Dict.put(addresses, key, balance)
  end
  def lose_key(address, pub, amount, key) do
    if is_binary(key) do key = String.to_atom(key) end
    f = fn(balance) ->
      Dict.put(balance, key, Dict.get(balance, key)-amount) 
    end
    modify_balance(address, pub, f)
  end
  def lose_cash(address, pub, amount) do
    lose_key(address, pub, amount, "cash")
  end
  def lose_bond(address, pub, amount) do
    lose_key(address, pub, amount, "bond")
  end
  def positive_balances(txs, bond_size, block_creator, cost, addresses \\ []) do
    if block_creator != nil and not(block_creator in Dict.keys(addresses)) do
      acc = KV.get(block_creator)
      balance = [cash: acc[:amount], bond: acc[:bond]]      
      addresses = [{String.to_atom(block_creator), balance}|addresses]#to_atom is dangerous!!
    end
    cond do
      txs==[] -> 
        if block_creator != nil do addresses = lose_cash(addresses, block_creator, cost) end
        all_positive(addresses)
      true -> positive_balances_1(txs, bond_size, block_creator, cost, addresses)
    end
  end
  def positive_balances_1(txs, bond_size, block_creator, cost, addresses) do
    [tx|txs]=txs
    pub=tx[:pub]
    type=tx[:data][:type]
    if not pub in Dict.keys(addresses) do
      acc = KV.get(pub)
      balance = [cash: acc[:amount], bond: acc[:bond]]
      addresses = [{String.to_atom(pub), balance}|addresses]#to_atom is dangerous!!!
    end
    cond do
      type == "spend" ->
        addresses = lose_cash(addresses, pub, tx[:data][:amount]+tx[:data][:fee])
      type == "spend2wait" ->
        addresses = lose_cash(addresses, pub, tx[:data][:amount]+tx[:data][:fee])
      type == "wait2bond" ->
        addresses = lose_cash(addresses, pub, tx[:data][:fee])
      type == "bond2spend" ->
        addresses = lose_bond(addresses, pub, tx[:data][:amount])
        addresses = lose_cash(addresses, pub, tx[:data][:fee])
      type == "sign" ->
        addresses = lose_bond(addresses, pub, bond_size*length(tx[:data][:winners]))
      type in [:slasher, :reveal, :sign] -> true
      true -> 
        IO.puts("no function with that name")
        true
    end
    positive_balances(txs, bond_size, block_creator, cost, addresses)
  end
end
defmodule VerifyTx do
  def spend?(tx, txs) do
    cond do
      tx[:data][:fee] < Constants.min_tx_fee ->
        IO.puts("fee too low")
        false
      tx[:data][:amount]+tx[:data][:fee] > Constants.max_bond_block ->
        IO.puts("too much money at once")
        false
      true -> true
    end
  end
  def spend2wait?(tx, txs) do
    acc=KV.get(tx[:"pub"])
    cond do
      {0,0}!=acc[:wait] -> false
      true -> true
    end
  end 
  def wait2bond?(tx, txs) do
    acc=KV.get(tx[:"pub"])    
    {a, h}=tx[:"data"][:"wait_money"]
    cond do
      {a, h}!=acc[:wait] -> false 
      h>KV.get("height")+Constants.epoch -> false 
      true -> true
    end
  end
    #If a user wants to take part in the consensus process, they would use this transaction type to turn some of their wait-money into bond-money. The price for bond-money changes continuously over time, and more bond-money is printed and given to the people who participate. If you participate, then the value of your bond-money will slowly grow. If you dont participate, then the value will quickly shrink. 
    #There is a moving exchange rate. Bond-coins are constantly losing value.
  def bond2spend?(tx, txs) do
    true
  end
  def winner?(balance, total, seed, pub, j) do#each address gets 200 chances.
    max=HashMath.hex2int("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")
    b=max*Constants.signers_per_block*balance/(Constants.chances_per_address*total)
    a=HashMath.hash2int(DetHash.doit({seed, pub, j}))
    a<b and j>=0 and j<Constants.chances_per_address and is_integer(j)
  end
  def first_bits(b, s) do
    <<c :: size(s), _ :: bitstring>>=b
    c
  end
  def ran_block(block) do
    #txs = BlockchainPure.get_block(height)[:"txs"]
    txs = block[:data][:txs]
    cond do
      is_nil(txs) -> 0
      true ->
        txs=Enum.filter(txs, &(&1[:"data"][:"type"]=="reveal"))
        txs=Enum.map(txs, &(first_bits(&1[:"data"][:"secret"], length(&1[:"data"][:"winners"])))) |> Enum.reduce("", &(&1 <> &2))
    end
  end
  def rng(hash, counter \\ 26, entropy \\ "" ) do #this needs to be memoized so bad.
    block = KV.get(hash)
    hash = block[:data][:hash]
    cond do
      hash == nil -> DetHash.doit(entropy)
      counter < 1 -> DetHash.doit(entropy)
      true -> rng(hash, counter - 1, ran_block(block) <> entropy)
    end
  end
  def sign?(tx, txs, prev_hash) do#block = [data: [hash: block_hash]]
    acc = KV.get(tx[:pub])
    tot_bonds = KV.get("tot_bonds")
    ran=rng(prev_hash)
    l=Enum.map(tx[:data][:winners], fn(x)->winner?(acc[:bond], tot_bonds, ran, tx[:pub], x) end)
    l1=l
    l=Enum.reduce(l, true, fn(x, y) -> x and y end)
    m = length(Enum.filter(txs, fn(t)-> t[:pub]==tx[:pub] and t[:data][:type] == "sign" end))
    cond do
      acc[:bond] < Constants.minbond -> 
        IO.puts("not enough bond-money to validate")
        false
      not is_binary(tx[:data][:secret_hash]) -> 
        IO.puts("should have been binary")
        false
      not l -> 
        IO.puts("not l")
        IO.puts("l1 #{inspect l1}")
        false
      length(tx[:data][:winners])<1 -> false
      m != 0 -> false
      not(KV.get("height")==0) and tx[:data][:prev_hash]!=prev_hash -> 
        IO.puts("hash not match")
        IO.puts("prev hash: #{inspect prev_hash}")
        IO.puts("tx: #{inspect tx}")
        false
      true -> true
    end
  end
  def slasher?(tx, txs) do
    {pub, _, tx}=tx
    false
    #If you can prove that the same address signed on 2 different blocks at the same height, then you can take 1/3rd of the deposit, and destroy the rest.
    #make sure they cannot do this repeatedly
  end
  def signed_block(tx) do Blockchain.get_block(tx[:data][:signed_on]) end
  def sign_tx(block, pub) do block[:data][:txs] |> Enum.filter(&(&1[:pub]==pub))  |> Enum.filter(&(&1[:data][:type]=="sign")) end
  def wins(block, tx) do 
  b=Blockchain.txs_filter(block[:txs], "sign") |> Enum.filter(&(tx[:pub]==&1[:pub])) 
  length(hd(b)[:data][:winners]) 
  end
  def reveal?(tx, txs) do
    old_block=signed_block(tx)
    revealed = txs |> Enum.filter(&(&1[:data][:type] == "reveal")) |> Enum.filter(&(&1[:pub]==tx[:pub]))
    signed=sign_tx(old_block, tx[:pub])
    bond_size = old_block[:data][:bond_size]
    cond do
      length(revealed) > 0 -> false
      length(signed)==0 -> 
        IO.puts "0"
        false
      byte_size(tx[:data][:secret])!=10 -> 
        IO.puts "1"
        false
      DetHash.doit(tx[:data][:secret]) != hd(signed)[:data][:secret_hash] -> 
        IO.puts "2"
        false
      tx[:pub] in old_block[:meta][:revealed] ->
        IO.puts "3"
        false
      tx[:data][:amount]!=bond_size*length(tx[:data][:winners]) -> 
        IO.puts "4 slfjksd"
        false
      KV.get("height")-Constants.epoch>tx[:data][:signed_on] -> 
        IO.puts "5"
        false
      true -> true
    end
    #After you sign, you wait a while, and eventually are able to make this tx. This tx reveals the random entropy_bit and salt from the sign tx, and it reclaims the safety deposit given in the sign tx. If your bit is in the minority, then your prize is bigger.
  end
  def check_tx(tx, txs, prev_hash) do
    cost = Constants.block_creation_fee
    cond do
      not check_logic(tx, txs, prev_hash) -> false
      not check_([data: [txs: [tx|txs]]], cost) -> false
      true -> true
    end
  end
  def check_logic(tx, txs, prev_hash) do
    f=[spend: &(spend?(&1, &2)),
       spend2wait: &(spend2wait?(&1, &2)),
       wait2bond: &(wait2bond?(&1, &2)),
       bond2spend: &(bond2spend?(&1, &2)),
       sign: &(sign?(&1, &2, prev_hash)),
       slasher: &(slasher?(&1, &2)),
       reveal: &(reveal?(&1, &2))]
    default = fn(_, _) -> false end
    cond do
      tx[:data][:type] == nil -> false
      not Dict.get(f, String.to_atom(tx[:data][:type]), default).(tx, txs) ->  false #to_atom is DANGEROUS
      not Sign.verify_tx(tx) -> 
        IO.puts("bad signature")
        false
      true -> true
    end
  end
  def remove_repeats(l) do
    cond do
      l==[] -> l
      hd(l) in tl(l) -> remove_repeats(tl(l))
      true -> [hd(l)|remove_repeats(tl(l))]
    end
  end
  def consecutive?(l) do# l is a list of numbers
    cond do
      length(l) < 2 -> true
      hd(l)+1 == hd(tl(l)) -> consecutive?(tl(l))
      true -> false
    end
  end
  def check_nonces(txs) do
    have_nonce = Enum.map(txs, fn(tx) -> tx[:data][:nonce]!=nil end)
    all_have_nonce = Enum.reduce(have_nonce, true, &(&1 and &2))
    pubs = txs |> Enum.map(fn(tx) -> tx[:pub] end) |> remove_repeats
    sorted_txs = Enum.map(pubs, fn(pub) -> Enum.filter(txs,  &(&1[:pub]==pub)) end)
    f = (fn(x) -> Enum.reduce(x, true, &(&1 and &2)) end)
    just_nonces = Enum.map(sorted_txs, fn(ts) -> 
      Enum.map(ts, &(&1[:data][:nonce])) |> Enum.sort 
    end)
    consecutive = just_nonces |> Enum.map(&(consecutive?(&1))) |> f.()
    current_nonce = Enum.map(pubs, fn(pub) -> KV.get(pub)[:nonce] end)
    starts_right = Enum.zip(current_nonce, just_nonces) |> Enum.map(fn(x)-> elem(x, 0)==hd(elem(x, 1)) end) |> f.()
    (starts_right and consecutive) and all_have_nonce
   end
   def check_(block, cost) do
     txs = block[:data][:txs]
     spending = Blockchain.being_spent(txs)
     winners = txs 
     |> Blockchain.txs_filter("sign") 
     |> Enum.map(fn(t) -> t[:data][:winners] end) 
     |> Enum.map(fn(w) -> length(w) end)
     |> Enum.reduce(0, &(&1+&2))
     cond do
       not check_nonces(txs) -> 
         IO.puts("bad nonce")
         false
       not VerifyBalances.positive_balances(txs,spending*3/max(winners, Constants.signers_per_block*2/3), block[:pub], cost)->
         IO.puts("someone spent more money than how much they have")
         false         
       true -> true
     end
  end
  def check_txs(block, cost) do#accept block as input
    txs = block[:data][:txs]
    prev_hash = block[:data][:hash]
    cond do
      not check_logics(txs, prev_hash, [])  ->
        IO.puts("bad logic")
        false
      txs==[] -> 
        IO.puts("no empty blocks")
        false
      not check_(block, cost) -> false
      true -> true
    end
  end
  def check_logics(new, prev_hash, old \\ []) do
    cond do
      length(new) ==0 -> true
      check_logic(hd(new), old, prev_hash) -> 
        check_logics(tl(new), prev_hash, [hd(new)|old])
      true -> false
    end
  end
end

