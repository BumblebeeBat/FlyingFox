defmodule Tcp.Supervisor do
  use Supervisor
  def start_link(opts) do
    Supervisor.start_link(__MODULE__, :ok, opts)
  end
  def start_bucket(port, supervisor) do
    Supervisor.start_child(supervisor, [port, supervisor])
  end
  def init(:ok) do
    children = [
      ]
    supervise(children, strategy: :simple_one_for_one)
  end

  def doit(f, port) do
    {:ok, sup} = start_link([f, port])
    {ok, socket} = Tcp.open(port)
    helper_1(sup, s, f, port)
  end
  def helper_1(sup, s, f, port) do
    {x, conn} = :gen_tcp.connect(:erlang.binary_to_list(host), port, [{:active, false}, {:packet, 0}])
    if x==:ok do
      spawn_link(fn -> :timer.sleep(10)
                       helper_1(sup, s, f, p) end)
      conn |> Tcp.listen |> f.() |> ms(conn)
    else
      IO.puts "failed to connect #{inspect conn}" 
      close(socket)
      :timer.sleep(500)
      spawn_link(fn -> doit(f, port) end)
    end      
  end


  def helper(sup) do
    {x, conn} = :gen_tcp.accept(socket)
    {:ok, bucket} = start_bucket(sup)
    helper(sup)
  end
end
defmodule TcpToo do
use Genserver
def init([port, supervisor]) do
  Tcp.open(port)
  {:ok, []}
end
def main(f, port) do
end

  def doit(f, port) do
    {ok, socket} = Tcp.open(port)
    helper_1(sup, s, f, port)
  end
  def helper_1(sup, s, f, port) do
    {x, conn} = :gen_tcp.connect(:erlang.binary_to_list(host), port, [{:active, false}, {:packet, 0}])
    if x==:ok do
      spawn_link(fn -> :timer.sleep(10)
                       Tcp.Supervisor.start_bucket(supervisor)
                       helper_1(sup, s, f, p) end)
      conn |> Tcp.listen |> f.() |> ms(conn)
    else
      IO.puts "failed to connect #{inspect conn}" 
      close(socket)
      :timer.sleep(500)
      spawn_link(fn -> doit(f, port) end)
    end      
  end


end
