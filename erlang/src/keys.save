%the hard drive stores {f, pubkey, encrypted(privkey), encrypted("sanity")).
%the ram stores either {pubkey, privkey} or {pubkey, ""} depending on if this node is locked.

-module(keys).
-behaviour(gen_server).
-export([doit/0, start_link/0, code_change/3, handle_call/3, handle_cast/2, handle_info/2, init/1, terminate/2]).
%location() -> "keys".
-define(LOC(), "keys").
-define(SANE(), "sanity").
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("keys died"), ok.
-record(f, {pub = "", priv = "", sanity = ""}).
init(ok) -> 
    X = db:read(?LOC()),
    if
        X == "" -> 
            K = #f{},
            db:save(?LOC(),K);
        true -> K = X
    end,
    {ok, K}.

handle_call(only, _From, X) -> {reply, X, X};
handle_call({ss, Pub}, _From, {MyPub, Priv}) ->
    {reply, sign:shared_secret(Pub, Priv), {MyPub, Priv}};
handle_call({raw_sign, _}, _From, {Pub, Priv}) when Priv=="" ->
    {reply, "need to unlock passphrase", {Pub, Priv}};
handle_call({raw_sign, M}, _From, X) when not is_binary(M) ->
    {reply, "not binary", X};
handle_call({raw_sign, M}, _From, {Pub, Priv}) ->
    {reply, sign:sign(M, Priv), {Pub, Priv}};
handle_call({sign, M}, _From, {Pub, Priv}) -> {reply, sign:sign_tx(M, Pub, Priv), {Pub, Priv}};
handle_call(status, _From, {Pub, Priv}) ->
    Y = db:read(?LOC()),
    out = if
        Y#f.priv == "" -> empty;
        priv == "" -> locked;
        true -> unlocked
    end,
    {reply, out, {Pub, Priv}};
handle_call(pubkey, _From, {Pub, Priv}) -> {reply, Pub, {Pub, Priv}}.
handle_cast({load, Pub, Priv, Brainwallet}, X) ->
    X = db:read(?LOC()),
    if
        X#f.priv == "" -> 
            store(pub, priv, Brainwallet),
            {noreply, {Pub, Priv}};
        true -> {noreply, X}
    end;
handle_cast({unlock, Brainwallet}, _) ->
    X = db:get_raw(?LOC()),
    ?SANE() = encryption:sym_dec(Brainwallet, X#f.sanity),
    Priv = encryption:sym_dec(Brainwallet, X#f.priv),
    {noreply, {X#f.pub, Priv}};
handle_cast(lock, {Pub, _Priv}) -> {noreply, {Pub, ""}};
handle_cast({change_password, Current, New}, {Pub, Priv}) ->
    X = db:get_raw(?LOC()),
    ?SANE() = encryption:sym_dec(Current, X#f.sanity),
    Priv = encryption:sym_dec(Current, X#f.priv),
    store(Pub, Priv, New),
    {noreply, {X#f.pub, Priv}};
handle_cast(_, X) -> {noreply, X}.
handle_info(_, X) -> {noreply, X}.

pubkey() -> gen_server:call(?MODULE, pubkey).
sign(M) -> gen_server:call(?MODULE, {sign, M}).
raw_sign(M) -> gen_server:call(?MODULE, {raw_sign, M}).
load(Pub, Priv, Brainwallet) -> gen_server:cast(?MODULE, {load, Pub, Priv, Brainwallet}).
unlock(Brainwallet) -> gen_server:cast(?MODULE, {unlock, Brainwallet}).
lock() -> gen_server:cast(?MODULE, lock).
status() -> gen_server:cast(?MODULE, status).
change_password(Current, New) -> gen_server:cast(?MODULE, {change_password, Current, New}).
new(Brainwallet) -> change_password("", Brainwallet).
shared_secret(Pub) -> gen_server(?MODULE, {ss, Pub}).

doit() -> gen_server:call(?MODULE, only).
store(Pub, Priv, Brainwallet) ->
    db:save(?LOC(),#f{pub=Pub, priv=encryption:sym_enc(brainwallet, Priv), sanity=encryption:sym_enc(?SANE(), Priv)}).
